"""Core models."""
# Copyright 2015 Solinea, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
import sys
import arrow
from django.utils import timezone
from jinja2 import Template
from django.conf import settings
from django.core.urlresolvers import reverse
from django.db import models
from django.db.models import CharField, IntegerField, ForeignKey
from django_extensions.db.fields import UUIDField, CreationDateTimeField, \
    ModificationDateTimeField
from elasticsearch_dsl import String, Date, Integer, A, Nested, Search
from elasticsearch_dsl.query import Q, QueryString      # pylint: disable=E0611
from picklefield.fields import PickledObjectField
from polymorphic import PolymorphicModel
from goldstone.drfes.new_models import DailyIndexDocType
from django.core.mail import send_mail
from goldstone.keystone.utils import get_client as get_keystone_client
from goldstone.nova.utils import get_client as get_nova_client
from goldstone.cinder.utils import get_client as get_cinder_client
from goldstone.glance.utils import get_client as get_glance_client
from goldstone.neutron.utils import get_client as get_neutron_client
from goldstone.user.models import User

logger = logging.getLogger(__name__)

# Aliases to make the Resource Graph definitions less verbose.
MAX = settings.R_ATTRIBUTE.MAX
MIN = settings.R_ATTRIBUTE.MIN
TO = settings.R_ATTRIBUTE.TO
TYPE = settings.R_ATTRIBUTE.TYPE
MATCHING_FN = settings.R_ATTRIBUTE.MATCHING_FN
EDGE_ATTRIBUTES = settings.R_ATTRIBUTE.EDGE_ATTRIBUTES

ALLOCATED_TO = settings.R_EDGE.ALLOCATED_TO
APPLIES_TO = settings.R_EDGE.APPLIES_TO
ASSIGNED_TO = settings.R_EDGE.ASSIGNED_TO
ATTACHED_TO = settings.R_EDGE.ATTACHED_TO
CONSUMES = settings.R_EDGE.CONSUMES
CONTAINS = settings.R_EDGE.CONTAINS
DEFINES = settings.R_EDGE.DEFINES
INSTANCE_OF = settings.R_EDGE.INSTANCE_OF
MEMBER_OF = settings.R_EDGE.MEMBER_OF
OWNS = settings.R_EDGE.OWNS
ROUTES_TO = settings.R_EDGE.ROUTES_TO
SUBSCRIBED_TO = settings.R_EDGE.SUBSCRIBED_TO
TOPOLOGICALLY_OWNS = settings.R_EDGE.TOPOLOGICALLY_OWNS
USES = settings.R_EDGE.USES


def _hash(*args):
    """Return a unique hash of the arguments.

    :param args: Values for generating the unique hash. We convert each one to
                 a string before adding it to the hash
    :type args: tuple
    :rtype: str

    """
    from hashlib import sha256

    result = sha256()
    for arg in args:
        result.update(str(arg))

    return result.hexdigest()


######################################
# Resource graph types and instances #
######################################

def utc_now():
    """Return a timezone-aware current UTC datetime.

    This is needed for a model field's default. It's called every time a row is
    created, and lambdas can't be used because they can't be serialized by
    migrations.

    """
    import arrow

    return arrow.utcnow().datetime


class PolyResource(PolymorphicModel):
    """The base type for resources.

    These are stored in the database.

    """

    # This object's Goldstone UUID.
    uuid = UUIDField(version=1, auto=True, primary_key=True)

    # This object's unique id within its OpenStack cloud. This may be an
    # OpenStack-generated string, or a value we generate from the object's
    # attributes.
    native_id = CharField(max_length=128)

    native_name = CharField(max_length=64)

    # This instance's outgoing edges, as [(dest_uuid, attribute_dict),
    # (dest_uuid, attribute_dict), ...]
    edges = PickledObjectField(default=[])

    # This node's cloud attributes.
    cloud_attributes = PickledObjectField(default={})

    created = CreationDateTimeField(editable=False, blank=True)

    updated = ModificationDateTimeField(editable=True, blank=True)

    class Meta:               # pylint: disable=C0111,W0232,C1001
        verbose_name = "polyresource"

    @classmethod
    def unique_class_id(cls):
        """Return this class' (not object!) unique id."""

        return str(cls)

    @classmethod
    def clouddata(cls):          # pylint: disable=R0201
        """Return information about all the objects of this type within the
        OpenStack cloud.

        :return: Attributes about each instance of this type. Included in each
                 entry are native ids (either returned from the OpenStack
                 client, or generated by Goldstone), resource names (extracted
                 from the resource graph), and resource types (ditto).

        :rtype: list of dict

        """

        return []

    @classmethod
    def resource_name_key(cls):
        """Return the key to use within a clouddata() entry to retrieve an
        instance's name.

        :rtype: str

        """

        return "name"

    @classmethod
    def resource_type_name_key(cls):
        """Return the key to use within a clouddata() entry to retrieve the
        name of an instance's type.

        :rtype: str

        """

        return "type_name"

    @classmethod
    def native_id_key(cls):
        """Return the key to use within a clouddata() entry to retrieve an
        instance's native id.

        Clouddata() returns a list of dicts. Each dict represents an instance
        within the cloud, and contains a native id which will be unique within
        the cloud. If OpenStack defines a unique id, then it's given it a name
        (i.e., key) within the instances' attributes. Otherwise, we create the
        native id ourselves.

        Semantically, this is a class property, but Python doesn't have class
        properties, so it's a method.

        :rtype: str

        """

        return "id"

    @classmethod
    def native_id_from_attributes(cls, attributes):
        """Return an instance's native id from its OpenStack attributes.

        :param attributes: An instance's attributes, e.g., from an
                           xxxxx_client() call
        :type attributes: dict

        """

        return attributes[cls.native_id_key()]

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type.

        :return: Entries in the form of:
                 TO: The destination type
                 MATCHING_FN: Callable(from_attr_dict, to_attr_dict).  If
                              there's a match between the from_node's and
                              to_node's attribute dicts, we draw a Resource
                              graph edge. Note: This must be prepared for
                              absent keys, and not throw exceptions.
                 EDGE_ATTTRIBUTES: This edge's attributes:
                     TYPE: The type of this edge
                     MIN: A resource graph node has a minimum number of this
                          edge ntype
                     MAX: A resource graph node has a maximum number of this
                          edge type
        :rtype: list of dict

        """

        return []

    @classmethod
    def resource_list_url(cls):
        """Return a relative URL for the the client's "resource list" display.

        This is currently defined only for leaf nodes. There's no reason why it
        couldn't include non-leaf nodes in the future.

        :rtype: str

        """

        return ''

    @classmethod
    def integration(cls):
        """Return the lowercase name of this node's integration. (nova,
        keystone, etc.)

        """

        return ''

    @classmethod
    def resourcetype(cls):
        """Return the name of this node's resource type.

        This should be lowercase plural.

        """

        return ''

    def label(self):                   # pylint: disable=R0201
        """Return the display name of this node's resource type.

        This should be lowercase plural. This will usually but not always be
        the same value as resourcetype(). E.g., a region's resourcetype() will
        return "region", and label() will return the region's name.

        """

        return self.resourcetype()

    def update_edges(self):
        """Update this persistent instance's edges with what's in the
        persistent resource graph."""

        outgoing = []

        # For every possible edge from this node's type...
        for edge in self.type_outgoing_edges():
            # Get the target neighbor's type and matching function.
            neighbor_type = edge[TO]
            match_fn = edge[MATCHING_FN]

            # For all nodes of the desired type...
            for candidate in neighbor_type.objects.all():
                if match_fn(self.cloud_attributes, candidate.cloud_attributes):
                    # We have a match! Create an edge to this candidate.
                    outgoing.append((candidate.uuid, edge[EDGE_ATTRIBUTES]))

        # Save the edges.
        self.edges = outgoing
        self.save()

    def logs(self):
        """Return a search object for logs related to this resource.

        The default implementation just looks for the name of the resource
        in any of the fields.

        """

        query = Q(QueryString(query=self.native_name))
        ss = SavedSearch.objects.get(name="log query")
        return ss.search().query(query)

    def events(self):
        """Return a search object for events related to this resource.

        The default implementation looks for logging event types with this
        resource name appearing in any field.

        """

        # this protects our hostname from being tokenized
        query = Q(QueryString(query=self.native_name))
        ss = SavedSearch.objects.get(name="event query")
        return ss.search().query(query)


############################################
# These classes represent add-on entities. #
############################################

class Addon(PolyResource):
    """The root node for user-installed Goldstone add-ons."""

    @classmethod
    def clouddata(cls):

        return [x.cloud_attributes for x in Addon.objects.all()]

    @classmethod
    def integration(cls):

        return "add-on"

    @classmethod
    def resourcetype(cls):

        return "add-ons"


###################################################
# These classes represent a Keystone integration. #
###################################################

class Keystone(PolyResource):
    """An OpenStack integration.

    This is a "virtual node". It exists to enhance the readability of the
    topology graph in the Goldstone client.

    """

    @classmethod
    def clouddata(cls):
        """Since this is a virtual node, the persistent resource graph objects
        are the, "nodes in the cloud." """

        return [x.cloud_attributes for x in Keystone.objects.all()]

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Endpoint,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Role,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: User,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Service,
                 MATCHING_FN: lambda f, t: "keystone" in t.get("name", ''),
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "keystone"


class User(PolyResource):
    """An OpenStack user."""

    @classmethod
    def clouddata(cls):
        """Because this is a topological leaf node, the returned list contains
        one entry."""

        keystone_client = get_keystone_client()

        if keystone_client.users.list():
            return [{"name": "users",
                     cls.native_id_key(): "users",
                     cls.resource_type_name_key(): cls.unique_class_id()}]
        else:
            return []

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Credential,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["user_id"],
                 EDGE_ATTRIBUTES: {TYPE: CONTAINS, MIN: 0, MAX: sys.maxint}},
                {TO: Credential,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["user_id"],
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Domain,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("domain_id") and f["domain_id"] == t["id"],
                 EDGE_ATTRIBUTES:
                 {TYPE: ASSIGNED_TO, MIN: 0, MAX: sys.maxint}},
                {TO: Group,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("domain_id") and f["domain_id"] == t["domain_id"],
                 EDGE_ATTRIBUTES:
                 {TYPE: ASSIGNED_TO, MIN: 0, MAX: sys.maxint}},
                {TO: Project,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("default_project_id") and
                 f["default_project_id"] == t["id"],
                 EDGE_ATTRIBUTES: {TYPE: ASSIGNED_TO, MIN: 0, MAX: 1}},
                {TO: QuotaSet,
                 MATCHING_FN: lambda f, t: False,
                 EDGE_ATTRIBUTES: {TYPE: SUBSCRIBED_TO,
                                   MIN: 0,
                                   MAX: sys.maxint}},
                ]

    @classmethod
    def resource_list_url(cls):

        return reverse("keystone-users") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "users"


class Domain(PolyResource):
    """An OpenStack domain."""

    @classmethod
    def clouddata(cls):

        keystone_client = get_keystone_client()

        result = []

        for entry in keystone_client.domains.list():
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Group,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["domain_id"],
                 EDGE_ATTRIBUTES: {TYPE: CONTAINS, MIN: 0, MAX: sys.maxint}},
                {TO: Group,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["domain_id"],
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Project,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["domain_id"],
                 EDGE_ATTRIBUTES: {TYPE: CONTAINS, MIN: 0, MAX: sys.maxint}},
                {TO: Project,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["domain_id"],
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "domains"


class Group(PolyResource):
    """An OpenStack group."""

    @classmethod
    def clouddata(cls):

        keystone_client = get_keystone_client()

        result = []

        for entry in keystone_client.groups.list():
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Domain,
                 MATCHING_FN:
                 lambda f, t: f.get("domain_id") and f["domain_id"] == t["id"],
                 EDGE_ATTRIBUTES: {TYPE: MEMBER_OF, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "groups"


class Token(PolyResource):
    """An OpenStack token."""

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: User,
                 EDGE_ATTRIBUTES: {TYPE: ASSIGNED_TO,
                                   MIN: 0,
                                   MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "tokens"


class Credential(PolyResource):
    """An OpenStack credential."""

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Project,
                 EDGE_ATTRIBUTES: {TYPE: ASSIGNED_TO, MIN: 1, MAX: 1}},
                ]

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "credentials"


class Role(PolyResource):
    """An OpenStack role.

    Because this is a topological leaf node, the returned list contains one
    entry.

    """

    @classmethod
    def clouddata(cls):

        keystone_client = get_keystone_client()

        if keystone_client.users.list():
            return [{"name": "roles",
                     cls.native_id_key(): "roles",
                     cls.resource_type_name_key(): cls.unique_class_id()}]
        else:
            return []

    @classmethod
    def resource_list_url(cls):

        return reverse("keystone-roles") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "roles"


class Region(PolyResource):
    """An OpenStack region."""

    @classmethod
    def clouddata(cls):

        keystone_client = get_keystone_client()

        result = []

        for entry in keystone_client.regions.list():
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Keystone,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["id"],
                 EDGE_ATTRIBUTES: {TYPE: TOPOLOGICALLY_OWNS, MIN: 1, MAX: 1}},
                {TO: Cinder,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["id"],
                 EDGE_ATTRIBUTES: {TYPE: TOPOLOGICALLY_OWNS, MIN: 1, MAX: 1}},
                {TO: Nova,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["id"],
                 EDGE_ATTRIBUTES: {TYPE: TOPOLOGICALLY_OWNS, MIN: 1, MAX: 1}},
                {TO: Neutron,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["id"],
                 EDGE_ATTRIBUTES: {TYPE: TOPOLOGICALLY_OWNS, MIN: 1, MAX: 1}},
                {TO: Glance,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["id"],
                 EDGE_ATTRIBUTES: {TYPE: TOPOLOGICALLY_OWNS, MIN: 1, MAX: 1}},
                {TO: Addon,
                 # Any add-on can be used in any region...
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES: {TYPE: TOPOLOGICALLY_OWNS, MIN: 1, MAX: 1}},
                ]

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "regions"

    def label(self):

        # Id always be there, but it won't be there in some unit tests.
        return self.cloud_attributes.get("id")    # pylint: disable=E1101


class Endpoint(PolyResource):
    """An OpenStack endpoint."""

    @classmethod
    def clouddata(cls):
        """Because this is a topological leaf node, the returned list contains
        one entry per interface."""

        keystone_client = get_keystone_client()

        # Note: Endpoints may have identical service_ids for the public,
        # private, and admin interfaces. The endpoint's dict will contain an
        # "interface" key, and we look for it.
        result = []
        seen_interfaces = set()

        for entry in keystone_client.endpoints.list():
            # this_entry = entry.to_dict()
            # interface = this_entry["interface"]
            interface = entry.interface

            if interface not in seen_interfaces:
                # We haven't seen this interface before.  Add it.
                seen_interfaces.add(interface)

                result.append({"name": "endpoints " + interface,
                               cls.native_id_key(): "endpoints " + interface,
                               "zone": interface,
                               cls.resource_type_name_key():
                               cls.unique_class_id()})

        return result

    @classmethod
    def resource_list_url(cls):

        return reverse("keystone-endpoints") + "/?region={region}&zone={zone}"

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "endpoints"

    def label(self):

        zone = self.cloud_attributes.get("zone")    # pylint: disable=E1101
        return "%s endpoints" % zone if zone else self.resourcetype()


class Service(PolyResource):
    """An OpenStack service.

    This type represents Keystone, Cinder, and Nova services.

    """

    @classmethod
    def clouddata(cls):
        """Because this is a topological leaf node, the returned list contains
        one entry per Keystone, Cinder, or Nova, if services exist for them."""

        # Set up to loop over the clients.
        keystone_client = get_keystone_client()
        cinder_client = get_cinder_client()
        nova_client = get_nova_client()

        # TODO add glance and neutron

        clients = [[keystone_client, "keystone services"],
                   [nova_client, "nova services"],
                   [cinder_client, "cinder services"]]

        result = []

        for client, client_name in clients:
            if client.services.list():
                # Services exist for this client.  Make a leaf node.
                result.append({"name": client_name,
                               cls.native_id_key(): client_name,
                               cls.resource_type_name_key():
                               cls.unique_class_id()})

        return result

    @classmethod
    def resource_list_url(cls):

        return "/{parent_integration}/" + cls().label() + "/?region={region}"

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "services"


class Project(PolyResource):
    """An OpenStack project.

    Note: We have no API endpoint for drilling down into interfaces yet.

    """

    @classmethod
    def clouddata(cls):

        keystone_client = get_keystone_client()

        result = []

        for entry in keystone_client.projects.list():
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Image,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: MEMBER_OF, MIN: 0, MAX: sys.maxint}},
                {TO: Keypair,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Keypair,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NovaLimits,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 1, MAX: 1}},
                {TO: Server,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 1, MAX: sys.maxint}},
                {TO: NeutronQuota,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: SUBSCRIBED_TO, MIN: 1, MAX: 1}},
                {TO: NeutronNetwork,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: USES, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronNetwork,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronSubnet,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronPort,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronSecurityGroupRule,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: QuotaSet,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES:
                 {TYPE: SUBSCRIBED_TO, MIN: 0, MAX: sys.maxint}},
                {TO: QOSSpec,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Snapshot,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Volume,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: MEMBER_OF, MIN: 0, MAX: sys.maxint}},
                {TO: Volume,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Limits,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "keystone"

    @classmethod
    def resourcetype(cls):

        return "projects"


###############################################
# These classes represent a Nova integration. #
###############################################

class Nova(PolyResource):
    """An OpenStack integration.

    This is a "virtual node". It exists to enhance the readability of the
    topology graph in the Goldstone client.

    """

    @classmethod
    def clouddata(cls):
        """Since this is a virtual node, the persistent resource graph objects
        are the, "nodes in the cloud." """

        return [x.cloud_attributes for x in Nova.objects.all()]

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Flavor,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Service,
                 MATCHING_FN: lambda f, t: "nova" in t.get("name", ''),
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Server,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Host,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Hypervisor,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: AvailabilityZone,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["zoneName"],
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 1, MAX: sys.maxint}},
                {TO: Cloudpipe,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t["zoneName"],
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 1, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "nova"


class AvailabilityZone(PolyResource):
    """An OpenStack Availability Zone."""

    @classmethod
    def clouddata(cls):

        nova_client = get_nova_client()

        result = []

        for entry in nova_client.availability_zones.list():
            this_entry = entry.to_dict()

            # The resource's name is at key "zoneName", so we have to copy it
            # to where the client expects it. And add the name of the resource
            # type.
            this_entry[cls.resource_name_key()] = this_entry.get("zoneName",
                                                                 "None")
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def native_id_key(cls):

        return "zoneName"

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [
            {TO: Aggregate,
             MATCHING_FN:
             lambda f, t:
             f.get("zoneName") and
             f.get("zoneName") == t.get("availability_zone"),
             EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
            {TO: Aggregate,
             MATCHING_FN:
             lambda f, t:
             f.get("zoneName") and
             f.get("zoneName") == t.get("availability_zone"),
             EDGE_ATTRIBUTES:
             {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
            {TO: Host,
             MATCHING_FN:
             lambda f, t:
             f.get("zoneName") and f.get("zoneName") == t.get("zone"),
             EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
            {TO: Host,
             MATCHING_FN:
             lambda f, t:
             f.get("zoneName") and f.get("zoneName") == t.get("zone"),
             EDGE_ATTRIBUTES:
             {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
            ]

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "availability zones"


class Aggregate(PolyResource):
    """An OpenStack Aggregate."""

    @classmethod
    def clouddata(cls):

        nova_client = get_nova_client()

        result = []

        # For every Aggregate in the cloud...
        for entry in nova_client.aggregates.list():
            # Make a dict for this entry, and concoct a unique id for it.
            this_entry = entry.to_dict()
            this_entry[cls.native_id_key()] = \
                cls.native_id_from_attributes(this_entry)

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def native_id_key(cls):

        return "unique_cloud_id"

    @classmethod
    def native_id_from_attributes(cls, attributes):

        return _hash(cls.unique_class_id(), attributes.get("id", ''))

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "aggregates"


class Flavor(PolyResource):
    """An OpenStack Flavor."""

    @classmethod
    def clouddata(cls):
        """Because this is a topological leaf node, the returned list contains
        one entry. """

        nova_client = get_nova_client()

        if nova_client.flavors.list():
            return [{"name": "flavors",
                     cls.native_id_key(): "flavors",
                     cls.resource_type_name_key(): cls.unique_class_id()}]
        else:
            return []

    @classmethod
    def native_id_key(cls):

        return "unique_cloud_id"

    @classmethod
    def native_id_from_attributes(cls, attributes):

        return _hash(cls.unique_class_id(), attributes.get("id", ''))

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [
            {TO: Server,
             MATCHING_FN:
             lambda f, t:
             f.get("id") and f.get("id") == t.get("flavor", {}).get("id"),
             EDGE_ATTRIBUTES: {TYPE: DEFINES, MIN: 0, MAX: sys.maxint}},
            {TO: Server,
             MATCHING_FN:
             lambda f, t:
             f.get("id") and f.get("id") == t.get("flavor", {}).get("id"),
             EDGE_ATTRIBUTES:
             {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
            ]

    @classmethod
    def resource_list_url(cls):

        return reverse("nova-flavors") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "flavors"


class Keypair(PolyResource):
    """An OpenStack Keypair."""

    @classmethod
    def clouddata(cls):

        nova_client = get_nova_client()

        result = []

        for entry in nova_client.keypairs.list():
            this_entry = entry.to_dict()["keypair"]

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def native_id_key(cls):

        return "fingerprint"

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Server,
                 # Any keypair can be used on any server.
                 MATCHING_FN:
                 lambda f, t:
                 f.get("fingerprint") is not None and t is not None,
                 EDGE_ATTRIBUTES:
                 {TYPE: ATTACHED_TO, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "keypairs"


class Host(PolyResource):
    """An Openstack host"""

    fqdn = CharField(max_length=255,
                     unique=True,
                     help_text="A fully-qualified domain name")

    @staticmethod
    def _parse_host_name(host_name):
        """Where possible, generate the fqdn and simple hostnames for host.

        :param host_name: An IP address, fqdn, or simple host name
        :type host_name: str
        :return: (simple name, fqdn)
        :rtype: tuple

        """
        from goldstone.utils import is_ip_addr, partition_hostname

        fqdn = None

        if not is_ip_addr(host_name):
            parts = partition_hostname(host_name)

            if parts['domainname'] is not None:
                fqdn = host_name
                host_name = parts['hostname']

        return host_name, fqdn

    @classmethod
    def clouddata(cls):

        nova_client = get_nova_client()
        hosts = [x.to_dict() for x in nova_client.hosts.list()]

        # Nova has no problem showing you multiple instance of the same host.
        # If a host shows up multiple times in the list, it probably has
        # multiple service running on it.  We'll de-dupe this, and preserve the
        # Availability Zone for each one.
        result = []

        # For every found host...
        for host in hosts:
            parsed_name = Host._parse_host_name(host["host_name"])[0]

            if all(x["host_name"] != parsed_name for x in result):
                # This is a new entry for the result set. Set the host_name
                # value, and concoct a unique id for it.
                host["host_name"] = parsed_name
                host[cls.native_id_key()] = cls.native_id_from_attributes(host)

                # The resource's name is at key "host_name", so we have to copy
                # it to where the client expects it. And add the name of the
                # resource type.
                host[cls.resource_name_key()] = host.get("host_name", "None")
                host[cls.resource_type_name_key()] = cls.unique_class_id()

                # We don't want or need this key.
                del host["service"]

                result.append(host)

        return result

    @classmethod
    def native_id_key(cls):

        return "unique_cloud_id"

    @classmethod
    def native_id_from_attributes(cls, attributes):

        return _hash(cls.unique_class_id(), attributes.get("host_name", ''))

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [
            {TO: Aggregate,
             MATCHING_FN:
             lambda f, t:
             f.get("host_name") and f.get("host_name") in t.get("hosts", []),
             EDGE_ATTRIBUTES: {TYPE: MEMBER_OF, MIN: 0, MAX: sys.maxint}},
            {TO: Hypervisor,
             MATCHING_FN:
             lambda f, t:
             f.get("host_name") and
             f.get("host_name") == t.get("hypervisor_hostname"),
             EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: 1}},
            {TO: Hypervisor,
             MATCHING_FN:
             lambda f, t:
             f.get("host_name") and
             f.get("host_name") == t.get("hypervisor_hostname"),
             EDGE_ATTRIBUTES:
             {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: 1}},
            ]

    @classmethod
    def resource_list_url(cls):

        # Unclear what the zone argument should be. Until this is resolved,
        # don't use it.
        # return reverse("nova-hosts") + "/?region={region}&zone={zone}"
        return reverse("nova-hosts") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "hosts"


class Hypervisor(PolyResource):
    """An OpenStack Hypervisor."""

    virt_cpus = IntegerField(editable=True, blank=True, default=8)
    memory = IntegerField(editable=True, blank=True, default=8192)

    @classmethod
    def clouddata(cls):

        nova_client = get_nova_client()

        result = []

        # For every Hypervisor in the cloud...
        for entry in nova_client.hypervisors.list():
            # Make a dict for this entry, and concoct a unique id for it.
            this_entry = entry.to_dict()
            this_entry[cls.native_id_key()] = \
                cls.native_id_from_attributes(this_entry)

            # Indicate that the hypervisor has no name, and add the name of the
            # resource type.
            this_entry[cls.resource_name_key()] = "None"
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def native_id_key(cls):

        return "unique_cloud_id"

    @classmethod
    def native_id_from_attributes(cls, attributes):

        return _hash(cls.unique_class_id(), attributes.get("id", ''))

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Server,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("id") and
                 f.get("id") == t.get("OS-EXT-SRV-ATTR:hypervisor_hostname"),
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Server,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("id") and
                 f.get("id") == t.get("OS-EXT-SRV-ATTR:hypervisor_hostname"),
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def resource_list_url(cls):

        return reverse("nova-hypervisors") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "hypervisors"


class Cloudpipe(PolyResource):
    """An OpenStack Cloudpipe."""

    @classmethod
    def clouddata(cls):

        nova_client = get_nova_client()

        result = []

        for entry in nova_client.cloudpipe.list():
            this_entry = entry.to_dict()

            # Indicate that the cloudpipe has no name, and add the name of the
            # resource type.
            this_entry[cls.resource_name_key()] = "None"
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def native_id_key(cls):

        return "project_id"

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [
            {TO: Server,
             MATCHING_FN:
             lambda f, t: f.get("id") and f.get("id") == t.get("id"),
             EDGE_ATTRIBUTES: {TYPE: INSTANCE_OF, MIN: 1, MAX: 1}},
            ]

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "cloudpipes"


class ServerGroup(PolyResource):
    """An OpenStack Server Group."""

    @classmethod
    def clouddata(cls):

        nova_client = get_nova_client()

        result = []

        # For every ServerGroup...
        for entry in nova_client.server_groups.list():
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "server groups"


class Server(PolyResource):
    """An OpenStack Server."""

    @classmethod
    def clouddata(cls):
        """Because this is a topological leaf node, the returned list contains
        one entry per availability_zone."""

        nova_client = get_nova_client()

        result = []
        seen_zones = set()

        for entry in nova_client.servers.list(search_opts={"all_tenants": 1}):
            zone = entry.to_dict()["OS-EXT-AZ:availability_zone"]

            if zone not in seen_zones:
                # We haven't seen this zone before.  Add it.
                seen_zones.add(zone)

                result.append({"name": "servers " + zone,
                               cls.native_id_key(): "servers " + zone,
                               "zone": zone,
                               cls.resource_type_name_key():
                               cls.unique_class_id()})

        return result

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Interface,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("addresses") and t.get("mac_addr") and
                 t.get("mac_addr") in
                 [y["OS-EXT-IPS-MAC:mac_addr"]
                  for x in f.get("addresses").values() for y in x],
                 EDGE_ATTRIBUTES: {TYPE: OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Interface,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("addresses") and t.get("mac_addr") and
                 t.get("mac_addr") in
                 [y["OS-EXT-IPS-MAC:mac_addr"]
                  for x in f.get("addresses").values() for y in x],
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: ServerGroup,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("hostId") and f.get("hostId") in t["members"],
                 EDGE_ATTRIBUTES: {TYPE: MEMBER_OF, MIN: 0, MAX: sys.maxint}},
                {TO: Volume,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("links") and t.get("links") and
                 any(volentry.get("href") and
                     volentry["href"] in [x["href"] for x in f["links"]]
                     for volentry in t["links"]),
                 EDGE_ATTRIBUTES:
                 {TYPE: ATTACHED_TO, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def resource_list_url(cls):

        return reverse("nova-servers") + "/?region={region}&zone={zone}"

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "servers"

    def label(self):

        zone = self.cloud_attributes.get("zone")    # pylint: disable=E1101

        if not zone or zone == "nova":
            return self.resourcetype()
        else:
            return "%s servers" % zone


class Interface(PolyResource):
    """An OpenStack Interface.

    Note: We have no API endpoint for drilling down into interfaces yet.

    """

    @classmethod
    def clouddata(cls):

        nova_client = get_nova_client()

        # Each server has an interface list. Since we're interested in the
        # Interfaces themselves, we flatten the list, and de-dup it.
        raw = [x.to_dict()
               for y in
               nova_client.servers.list(search_opts={"all_tenants": 1})
               for x in y.interface_list()]

        mac_addresses = set()
        result = []

        for entry in raw:
            if entry["mac_addr"] not in mac_addresses:
                # We haven't seen this MAC address before. Give it a "None"
                # name, add its resource type, and add it to the result.
                entry[cls.resource_name_key()] = "None"
                entry[cls.resource_type_name_key()] = cls.unique_class_id()

                result.append(entry)

                # Remember we've seen this MAC address.
                mac_addresses.add(entry["mac_addr"])

        return result

    @classmethod
    def native_id_key(cls):

        return "mac_addr"

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "interfaces"


class NovaLimits(PolyResource):
    """An OpenStack Limits within a Nova integration."""

    @classmethod
    def clouddata(cls):

        nova_client = get_nova_client()

        result = []

        for entry in nova_client.limits.list():
            this_entry = entry.to_dict()

            # This has no name, and add the name of the resource type.
            this_entry[cls.resource_name_key()] = "None"
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def integration(cls):

        return "nova"

    @classmethod
    def resourcetype(cls):

        return "limits"


#################################################
# These classes represent a Glance integration. #
#################################################

class Glance(PolyResource):
    """An OpenStack integration.

    This is a "virtual node". It exists to enhance the readability of the
    topology graph in the Goldstone client.

    """

    @classmethod
    def clouddata(cls):
        """Since this is a virtual node, the persistent resource graph objects
        are the, "nodes in the cloud." """

        return [x.cloud_attributes for x in Glance.objects.all()]

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Image,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "glance"

    @classmethod
    def resourcetype(cls):

        return "glance"


class Image(PolyResource):
    """An OpenStack Image."""

    @classmethod
    def clouddata(cls):
        """Because this is a topological leaf node, the returned list contains
        one entry."""

        glance_client = get_glance_client()

        if glance_client.images.list():
            return [{"name": "images",
                     cls.native_id_key(): "images",
                     cls.resource_type_name_key(): cls.unique_class_id()}]
        else:
            return []

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Server,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f.get("id") == t.get("id"),
                 EDGE_ATTRIBUTES: {TYPE: DEFINES, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def resource_list_url(cls):

        return reverse("glance-images") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "glance"

    @classmethod
    def resourcetype(cls):

        return "images"


#################################################
# These classes represent a Cinder integration. #
#################################################

class Cinder(PolyResource):
    """An OpenStack integration.

    This is a "virtual node". It exists to enhance the readability of the
    topology graph in the Goldstone client.

    """

    @classmethod
    def clouddata(cls):
        """Since this is a virtual node, the persistent resource graph objects
        are the, "nodes in the cloud." """

        return [x.cloud_attributes for x in Cinder.objects.all()]

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: VolumeType,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Snapshot,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Transfer,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: Service,
                 MATCHING_FN: lambda f, t: "cinder" in t.get("name", ''),
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "cinder"

    @classmethod
    def resourcetype(cls):

        return "cinder"


class QuotaSet(PolyResource):
    """An OpenStack Quota Set."""

    @classmethod
    def native_id_key(cls):

        return "unique_cloud_id"

    @classmethod
    def integration(cls):

        return "cinder"

    @classmethod
    def resourcetype(cls):

        return "quota sets"


class QOSSpec(PolyResource):
    """An OpenStack Quality Of Service Specification."""

    @classmethod
    def clouddata(cls):

        result = []

        for entry in get_cinder_client().qos_specs.list():
            # Make a dict for this entry.
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: VolumeType,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("id") and
                 f.get("id") in t.get("extra_specs", {}).get("qos", ''),
                 EDGE_ATTRIBUTES: {TYPE: APPLIES_TO, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "cinder"

    @classmethod
    def resourcetype(cls):

        return "qos specs"


class Snapshot(PolyResource):
    """An OpenStack Snapshot."""

    @classmethod
    def clouddata(cls):

        result = []

        for entry in get_cinder_client().volume_snapshots.list():
            # Make a dict for this entry.
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Volume,
                 MATCHING_FN:
                 lambda f, t:
                 f.get("id") and f.get("id") == t.get("snapshot_id"),
                 EDGE_ATTRIBUTES: {TYPE: APPLIES_TO, MIN: 1, MAX: 1}},
                ]

    @classmethod
    def resource_list_url(cls):

        return reverse("cinder-snapshots") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "cinder"

    @classmethod
    def resourcetype(cls):

        return "snapshots"


class Transfer(PolyResource):
    """An OpenStack Transfer."""

    @classmethod
    def clouddata(cls):

        result = []

        for entry in get_cinder_client().transfers.list():
            # Make a dict for this entry.
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def resource_list_url(cls):

        return reverse("cinder-transfers") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "cinder"

    @classmethod
    def resourcetype(cls):

        return "transfers"


class VolumeType(PolyResource):
    """An OpenStack Volume Type."""

    @classmethod
    def clouddata(cls):

        result = []

        # N.B.: Unlike most OpenStack client calls, this returns the relevant
        # data in the _info attribute.  Sigh.
        for entry in get_cinder_client().volume_types.list():
            # Add the name of the resource type.
            this_entry = entry._info              # pylint: disable=W0212
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: Volume,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t.get("volume_type"),
                 EDGE_ATTRIBUTES: {TYPE: APPLIES_TO, MIN: 0, MAX: sys.maxint}},
                {TO: Volume,
                 MATCHING_FN:
                 lambda f, t: f.get("id") and f["id"] == t.get("volume_type"),
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def resource_list_url(cls):

        return reverse("cinder-volume-types") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "cinder"

    @classmethod
    def resourcetype(cls):

        return "volume types"


class Volume(PolyResource):
    """An OpenStack Volume."""

    @classmethod
    def clouddata(cls):

        result = []

        for entry in get_cinder_client().volumes.list():
            # Make a dict for this entry.
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def resource_list_url(cls):

        return reverse("cinder-volumes") + "/?region={region}"

    @classmethod
    def integration(cls):

        return "cinder"

    @classmethod
    def resourcetype(cls):

        return "volumes"


class Limits(PolyResource):
    """An OpenStack Limit."""

    @classmethod
    def clouddata(cls):

        result = []

        for entry in get_glance_client().images.list():
            # Make a dict for this entry.
            this_entry = entry.to_dict()

            # Add the name of the resource type.
            this_entry[cls.resource_name_key()] = "None"
            this_entry[cls.resource_type_name_key()] = cls.unique_class_id()

            result.append(this_entry)

        return result

    @classmethod
    def integration(cls):

        return "cinder"

    @classmethod
    def resourcetype(cls):

        return "limits"


##################################################
# These classes represent a Neutron integration. #
##################################################

class Neutron(PolyResource):
    """An OpenStack integration.

    This is a "virtual node". It exists to enhance the readability of the
    topology graph in the Goldstone client.

    """

    @classmethod
    def clouddata(cls):
        """Since this is a virtual node, the persistent resource graph objects
        are the, "nodes in the cloud." """

        return [x.cloud_attributes for x in Neutron.objects.all()]

    @classmethod
    def type_outgoing_edges(cls):      # pylint: disable=R0201
        """Return the edges leaving this type."""

        return [{TO: NeutronAgent,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronExtension,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronSubnetPool,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronRouter,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronNetwork,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronSubnet,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronFloatingIP,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronPort,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronSecurityGroup,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronSecurityGroupRule,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                {TO: NeutronQuota,
                 MATCHING_FN: lambda f, t: True,
                 EDGE_ATTRIBUTES:
                 {TYPE: TOPOLOGICALLY_OWNS, MIN: 0, MAX: sys.maxint}},
                ]

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "neutron"


def _neutron_clouddata(cls, name, native_id):
    """Helper function to extract clouddata info from neutron client calls"""

    return [{"name": name,
             cls.native_id_key(): native_id,
             cls.resource_type_name_key(): cls.unique_class_id()}]


class NeutronAgent(PolyResource):
    """An OpenStack Neutron Agent."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "agents", "agents")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "agents"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-agents") + "/?region={region}"


class NeutronExtension(PolyResource):
    """An OpenStack Neutron Extension."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "extensions", "extensions")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "extensions"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-extensions") + "/?region={region}"


class NeutronQuota(PolyResource):
    """An OpenStack Neutron Quota."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "quotas", "quotas")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "quotas"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-quotas") + "/?region={region}"


class NeutronSecurityGroupRule(PolyResource):
    """An OpenStack Security Rules."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "security group rules",
                                  "security group rules")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "security group rules"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-security-group-rules") + "/?region={region}"


class NeutronSecurityGroup(PolyResource):
    """An OpenStack Security Group."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "security groups",
                                  "security groups")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "security groups"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-security-groups") + "/?region={region}"


class NeutronPort(PolyResource):
    """An OpenStack Port."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "ports", "ports")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "ports"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-ports") + "/?region={region}"


class NeutronFloatingIP(PolyResource):
    """An OpenStack Floating IP address."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "floating IPs", "floating IPs")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "floating ip addresses"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-floating-ips") + "/?region={region}"


class NeutronSubnet(PolyResource):
    """An OpenStack subnet."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "subnets", "subnets")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "subnets"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-subnets") + "/?region={region}"


class NeutronSubnetPool(PolyResource):
    """An OpenStack Neutron Subnet Pool."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "subnet pools", "subnet pools")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "subnet pools"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-subnet-pools") + "/?region={region}"


class NeutronNetwork(PolyResource):
    """An OpenStack network."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "networks", "networks")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "networks"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-networks") + "/?region={region}"


class NeutronRouter(PolyResource):
    """An OpenStack router."""

    @classmethod
    def clouddata(cls):
        return _neutron_clouddata(cls, "routers", "routers")

    @classmethod
    def integration(cls):

        return "neutron"

    @classmethod
    def resourcetype(cls):

        return "routers"

    @classmethod
    def resource_list_url(cls):

        return reverse("neutron-routers") + "/?region={region}"


class SavedSearch(models.Model):
    """Defined searches, both system and user-created.  The target_interval
     field can be used by the task subsystem to determine if a search should
     be executed."""

    uuid = UUIDField(version=4, auto=True, primary_key=True)

    name = models.CharField(max_length=64)

    owner = models.CharField(max_length=64)

    description = models.CharField(max_length=1024, blank=True, null=True)

    query = models.TextField(help_text='JSON Elasticsearch query body')

    protected = models.BooleanField(default=False,
                                    help_text='True if this is system-defined')

    hidden = models.BooleanField(blank=True, default=False,
                                 help_text='True if this search should not be'
                                           'presented via the view')

    index_prefix = models.CharField(max_length=64)

    doc_type = models.CharField(max_length=64, blank=True, null=True,
                                default=None)

    timestamp_field = models.CharField(max_length=64, null=True)

    # last_start and last_end are maintained via the
    # update_recent_search_window method.  they can be used to make a series
    # of calls that cover a contiguous time window (such as for dumping
    # data or checking for alerts periodically).
    # target_interval can be used to trigger a recurring search based on an ES
    # interval specification such as 5m or 1d.  A celery task that processes
    # SavedSearches can choose to trigger only if now - interval >= last_end.
    # BEWARE of multiple tasks using these values since they might step on
    # each other.  In the long run, these should be refactored into something
    # a little more protected from side effects by other tasks.  Possibly a
    # SearchSchedule type with a FK relationship to the search.
    last_start = models.DateTimeField(default=timezone.now)
    last_end = models.DateTimeField(default=timezone.now)
    target_interval = models.IntegerField(default=0)

    created = CreationDateTimeField(editable=False, blank=True, null=True)

    updated = ModificationDateTimeField(editable=True, blank=True, null=True)

    class Meta:               # pylint: disable=C0111,W0232,C1001
        unique_together = ('name', 'owner')
        verbose_name_plural = "saved searches"

    def search(self):
        """Returns an unbounded search object based on the saved query. Call
        the execute method when ready to retrieve the results."""
        import json

        s = Search.from_dict(json.loads(self.query))\
            .using(DailyIndexDocType._doc_type.using)\
            .index(self.index_prefix)

        if self.doc_type is not None:
            s = s.doc_type(self.doc_type)

        return s

    def search_recent(self):
        """Returns a search object that ranged to [last_end, now), and the start
        and end times as strings (suitable for updating the SavedSearch record.
        The caller is responsible for updating the last_start and last_end
        fields in the SavedSearch.
        """
        import arrow

        if self.timestamp_field is None:
            return self.search()

        start = self.last_end

        end = arrow.utcnow().datetime

        s = self.search()\
            .query('range',
                   ** {self.timestamp_field: {'gt': start.isoformat(),
                                              'lte': end.isoformat()}})
        return s, start, end

    def update_recent_search_window(self, start, end):
        """trigger an update of the last_start and last_end fields and persist
        the changes"""

        self.last_start = start
        self.last_end = end
        return self.save()

    def __unicode__(self):
        """Return a useful string."""

        return "%s owned by %s (%s)" % \
            (self.name, self.owner, self.uuid)


class AlertDefinition(models.Model):

    uuid = UUIDField(version=4, auto=True, primary_key=True)

    name = models.CharField(max_length=64)

    description = models.CharField(max_length=1024, blank=True, null=True)

    short_template = models.TextField(
        default='Alert: {{_alert_name}} triggered with {{_search_hits}} hits '
                'at {{_end_time}}')

    long_template = models.TextField(
        default='There were {{_search_hits}} matching records for the '
                '{{_search_name}} search (id: {{_search_id}}) between '
                '{{_start_time}} and {{_end_time}}.\n\nAlert ID: '
                '{{_alert_id}}')

    enabled = models.BooleanField(default=True)

    created = CreationDateTimeField(editable=False, blank=True, null=True)

    updated = ModificationDateTimeField(editable=True, blank=True, null=True)

    search = ForeignKey(SavedSearch, editable=False)

    def evaluate(self, search_result, start_time, end_time):

            kv_pairs = {
                '_alert_name': self.name,
                '_search_hits': search_result['hits']['total'],
                '_search_name': self.search.name,
                '_search_id': self.search.uuid,
                '_start_time': start_time,
                '_end_time': end_time,
                '_alert_id': self.uuid
            }

            if kv_pairs['_search_hits'] > 0:

                short = Template(self.short_template).render(kv_pairs)
                long = Template(self.long_template).render(kv_pairs)

                # create an alert and call all our producers with it
                alert = Alert(short_message=short, long_message=long,
                              alert_def=self, owner=self.owner)
                alert.save()

                # send the alert to all registered producers
                for producer in Producer.objects.filter(alert_def=self):
                    producer.produce(alert)


class Alert(models.Model):

    uuid = UUIDField(version=4, auto=True, primary_key=True)

    short_message = models.TextField()

    long_message = models.TextField()

    alert_def = ForeignKey(AlertDefinition, editable=False,
                           on_delete=models.PROTECT)

    created = CreationDateTimeField(editable=False, blank=True, null=True)

    updated = ModificationDateTimeField(editable=True, blank=True, null=True)


class Producer(PolymorphicModel):
    """
        Generic interface class for an alert producer. This contains generic
        producer related information such as sender, receiver names, id's,
        host, auth-params etc

        Specific types like email, slack, HTTP-POST etc inherit from this
        class with specific connection attributes
    """

    uuid = UUIDField(version=4, auto=True, primary_key=True)

    alert_def = models.ForeignKey(AlertDefinition)

    class Meta:
        abstract = True

    @classmethod
    def produce(self, alert):
        raise NotImplementedError("Producer subclass must implement send.")


class EmailProducer(Producer):
    """
        Specific interface class to prepare and send an email.
        Class gets all of its email contents from the parent producer class.
        This class only contains methods specific to a mailing interface.
    """

    sender = models.EmailField(max_length=128, default="GoldstoneServer")

    receiver = models.EmailField(max_length=128, blank=False, null=False)

    def produce(self, alert):

        email_rv = send_mail(alert.short_message, alert.long_message,
                             self.sender, self.receiver,
                             fail_silently=False)
        return email_rv


class CADFEventDocType(DailyIndexDocType):
    """ES representation of a PyCADF event. Attempting to write traits that are
    not present in the Nested definition will result in an exception, though
    reading events from ES that have additional traits should succeed. Subclass
    this class to define custom traits for your own event types.
    """

    INDEX_DATE_FMT = 'YYYY-MM-DD'

    timestamp = Date()

    traits = Nested(
        properties={
            'action': String(),
            'eventTime': Date(),
            'eventType': String(),
            'id': String(),
            'initiatorId': String(),
            'name': String(),
            'observerId': String(),
            'outcome': String(),
            'targetId': String(),
            'typeURI': String(),
        }
    )

    class Meta:
        doc_type = 'goldstone_event'
        index = 'events_*'

    def __init__(self, timestamp=None, event=None, **kwargs):
        if event is not None:
            kwargs = dict(
                kwargs.items() + self._get_traits_dict(event).items())

        if timestamp is None:
            kwargs['timestamp'] = arrow.utcnow().datetime

        super(CADFEventDocType, self).__init__(**kwargs)

    @staticmethod
    def _get_traits_dict(e):
        """
        convert a pycadf.event to an ES doc
        :param e:
        :return: dict
        """
        return {"traits": e.as_dict()}
